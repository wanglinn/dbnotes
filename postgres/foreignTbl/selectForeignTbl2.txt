外表生成执行计划逻辑实现

外表同普通表执行计划应该没啥区别。

1. 在函数 create_scan_plan 中添加

    case T_ForeignScan:
        plan = (Plan *) create_foreignscan_plan(root,
                                (ForeignPath *) best_path,
                                                tlist,
                                                scan_clauses);

2. 在plannodes.h 中添加

typedef struct ForeignScan
{
    Scan        scan;
    CmdType        operation;        /* SELECT/INSERT/UPDATE/DELETE */
    Oid            fs_server;        /* OID of foreign server */
    List       *fdw_exprs;        /* expressions that FDW may evaluate */
    List       *fdw_private;    /* private data for FDW */
    List       *fdw_scan_tlist; /* optional tlist describing scan tuple */
    List       *fdw_recheck_quals;    /* original quals not in scan.plan.qual */
    Bitmapset  *fs_relids;        /* RTIs generated by this scan */
    bool        fsSystemCol;    /* true if any "system column" is needed */
} ForeignScan;



3. 添加函数 create_foreignscan_plan 实现

其中 rel->fdwroutine->GetForeignPlan 对应函数 fileGetForeignPlan

/*
 * create_foreignscan_plan
 *     Returns a foreignscan plan for the relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */
static ForeignScan *
create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
                        List *tlist, List *scan_clauses)
{
    ForeignScan *scan_plan;
    RelOptInfo *rel = best_path->path.parent;
    Index        scan_relid = rel->relid;
    Oid            rel_oid = InvalidOid;
    Plan       *outer_plan = NULL;

    Assert(rel->fdwroutine != NULL);

    /* transform the child path if any */
    if (best_path->fdw_outerpath)
        outer_plan = create_plan_recurse(root, best_path->fdw_outerpath,
                                         CP_EXACT_TLIST);

    /*
     * If we're scanning a base relation, fetch its OID.  (Irrelevant if
     * scanning a join relation.)
     */
    if (scan_relid > 0)
    {
        RangeTblEntry *rte;

        Assert(rel->rtekind == RTE_RELATION);
        rte = planner_rt_fetch(scan_relid, root);
        Assert(rte->rtekind == RTE_RELATION);
        rel_oid = rte->relid;
    }

    /*
     * Sort clauses into best execution order.  We do this first since the FDW
     * might have more info than we do and wish to adjust the ordering.
     */
    scan_clauses = order_qual_clauses(root, scan_clauses);

    /*
     * Let the FDW perform its processing on the restriction clauses and
     * generate the plan node.  Note that the FDW might remove restriction
     * clauses that it intends to execute remotely, or even add more (if it
     * has selected some join clauses for remote use but also wants them
     * rechecked locally).
     */
    scan_plan = rel->fdwroutine->GetForeignPlan(root, rel, rel_oid,
                                                best_path,
                                                tlist, scan_clauses,
                                                outer_plan);

    /* Copy cost data from Path to Plan; no need to make FDW do this */
    copy_generic_path_info(&scan_plan->scan.plan, &best_path->path);

    /* Copy foreign server OID; likewise, no need to make FDW do this */
    scan_plan->fs_server = rel->serverid;

    /*
     * Likewise, copy the relids that are represented by this foreign scan. An
     * upper rel doesn't have relids set, but it covers all the base relations
     * participating in the underlying scan, so use root's all_baserels.
     */
    if (IS_UPPER_REL(rel))
        scan_plan->fs_relids = root->all_baserels;
    else
        scan_plan->fs_relids = best_path->path.parent->relids;

    /*
     * If this is a foreign join, and to make it valid to push down we had to
     * assume that the current user is the same as some user explicitly named
     * in the query, mark the finished plan as depending on the current user.
     */
    if (rel->useridiscurrent)
        root->glob->dependsOnRole = true;

    /*
     * Replace any outer-relation variables with nestloop params in the qual,
     * fdw_exprs and fdw_recheck_quals expressions.  We do this last so that
     * the FDW doesn't have to be involved.  (Note that parts of fdw_exprs or
     * fdw_recheck_quals could have come from join clauses, so doing this
     * beforehand on the scan_clauses wouldn't work.)  We assume
     * fdw_scan_tlist contains no such variables.
     */
    if (best_path->path.param_info)
    {
        scan_plan->scan.plan.qual = (List *)
            replace_nestloop_params(root, (Node *) scan_plan->scan.plan.qual);
        scan_plan->fdw_exprs = (List *)
            replace_nestloop_params(root, (Node *) scan_plan->fdw_exprs);
        scan_plan->fdw_recheck_quals = (List *)
            replace_nestloop_params(root,
                                    (Node *) scan_plan->fdw_recheck_quals);
    }

    /*
     * If rel is a base relation, detect whether any system columns are
     * requested from the rel.  (If rel is a join relation, rel->relid will be
     * 0, but there can be no Var with relid 0 in the rel's targetlist or the
     * restriction clauses, so we skip this in that case.  Note that any such
     * columns in base relations that were joined are assumed to be contained
     * in fdw_scan_tlist.)    This is a bit of a kluge and might go away
     * someday, so we intentionally leave it out of the API presented to FDWs.
     */
    scan_plan->fsSystemCol = false;
    if (scan_relid > 0)
    {
        Bitmapset  *attrs_used = NULL;
        ListCell   *lc;
        int            i;

        /*
         * First, examine all the attributes needed for joins or final output.
         * Note: we must look at rel's targetlist, not the attr_needed data,
         * because attr_needed isn't computed for inheritance child rels.
         */
        pull_varattnos((Node *) rel->reltarget->exprs, scan_relid, &attrs_used);

        /* Add all the attributes used by restriction clauses. */
        foreach(lc, rel->baserestrictinfo)
        {
            RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);

            pull_varattnos((Node *) rinfo->clause, scan_relid, &attrs_used);
        }

        /* Now, are any system columns requested from rel? */
        for (i = FirstLowInvalidHeapAttributeNumber + 1; i < 0; i++)
        {
            if (bms_is_member(i - FirstLowInvalidHeapAttributeNumber, attrs_used))
            {
                scan_plan->fsSystemCol = true;
                break;
            }
        }

        bms_free(attrs_used);
    }

    return scan_plan;
}



#0  create_foreignscan_plan (root=0x1e0eb88, best_path=0x1e09680, tlist=0x1e09d48, scan_clauses=0x0) at createplan.c:3439
#1  0x000000000082e8c2 in create_scan_plan (root=0x1e0eb88, best_path=0x1e09680, flags=1) at createplan.c:693
#2  0x000000000082d8e2 in create_plan_recurse (root=0x1e0eb88, best_path=0x1e09680, flags=1) at createplan.c:378
#3  0x000000000082d7e9 in create_plan (root=0x1e0eb88, best_path=0x1e09680) at createplan.c:315
#4  0x000000000083f35d in standard_planner (parse=0x1e0e140, cursorOptions=256, boundParams=0x0) at planner.c:340
#5  0x000000000083f043 in planner (parse=0x1e0e140, cursorOptions=256, boundParams=0x0) at planner.c:209
#6  0x000000000095af2d in pg_plan_query (querytree=0x1e0e140, cursorOptions=256, boundParams=0x0) at postgres.c:819
#7  0x000000000095b081 in pg_plan_queries (querytrees=0x1e0eab8, cursorOptions=256, boundParams=0x0) at postgres.c:885
#8  0x000000000095db66 in exec_simple_query (query_string=0x1e0d230 "select * from agg_text ;") at postgres.c:1050
#9  0x000000000095d0e4 in PostgresMain (argc=1, argv=0x1db9740, dbname=0x1d8de50 "postgres", username=0x1db95a8 "user1")
    at postgres.c:4117
#10 0x000000000089d316 in BackendRun (port=0x1daf000) at postmaster.c:4405
#11 0x000000000089c940 in BackendStartup (port=0x1daf000) at postmaster.c:4077
#12 0x0000000000898e1c in ServerLoop () at postmaster.c:1755
#13 0x0000000000896344 in PostmasterMain (argc=1, argv=0x1d8bd10) at postmaster.c:1363
#14 0x00000000007b3550 in main (argc=1, argv=0x1d8bd10) at main.c:228
